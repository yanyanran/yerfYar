# yerfYar
yerfYar是一个运行于Linux系统的，易于使用的分布式面向消息的中间件，由Go语言开发。该项目的目标是提供一个通用的、用于存储任何类型事件或日志的持久中间存储缓冲区。

消息由换行符分隔，事件格式没有其他限制：可以是JSON、纯文本、Protobuf（使用“\”和换行符转义）等。

## Go版本
构建yerfYar需要`go1.18.1`以上版本。

## 安装
1、在 https://golang.org/ 安装 Go

2、在终端中运行以下命令：`$ go install -v github.com/yanyanran/yerfYar@latest`

3、构建的二进制文件应位于“~/go/bin/yerfYar”，如果设置了“$GOPATH”，则应位于“$GOPATH/bin/yerfYar”。

## 用法
可参考简单的Go客户端库：https://pkg.go.dev/github.com/YuriyNasretdinov/chukcha/client

## 功能（正在进行）
1、开箱即用配置，数据持久化且不会意外丢失数据。

2、分布式，默认为异步复制。

3、明确确认已读取的数据。

## 复制

1、数据目录中的每个文件如下所示：`<category>/<server_name>-chuckXXXXXXXX`

2、集群中的每个实例都必须具有唯一的名称，并且该名称将用作该类别中所有文件的前缀。

3、客户端将只连接到一个实例，并使用已下载到当前实例的所有服务器中的块。

## 设计（在建工程）

1、数据被分割成块，并作为文件存储在磁盘上。每个服务器都拥有正在写入的块，并且每个单独块的所有权永远不会改变。这些文件被复制到集群中的所有其他服务器上。

2、reader明确确认已读取的数据，负责从适当的偏移量开始读取块。需要的话数据可以在设定的时间段后过期（TODO），当前默认情况下的数据永远不会过期。

## TODO
1、最大消息大小的限制是1MB，否则无法再从磁盘提供结果。

3、处理磁盘空间或索引节点数量不足的情况。

## 局限性
1、每条消息支持的最大大小为 1 MB。

2、每条消息必须用换行符 (`\n`) 分隔。

3、最大默认写入批量大小为 4 MB。

4、每个连接的最大内存消耗约为“（写入批量大小）* 2”（默认设置为 8 MB）。【TODO：如果在 HTTP 之上使用自定义协议，则可以显着降低每个连接的内存消耗】

5、打开连接数默认上限为262144。

## 数据丢失场景
默认情况下数据不会在每次写入时刷新到磁盘，但可以在服务器配置中或根据请求进行更改。

因此，数据持久性保证如下：

1、默认情况下，下面的情况可能会导致写入单个节点的数据丢失：
- 机器没有完全关闭，例如：发生内核崩溃或主机遇到任何其他硬件故障
- 机器完全丢失且再也没回到集群中

2、(TODO): 当 `min_sync_replicas` 大于 0 时，只有在以下情况下才会丢失数据：
- 超过“min_sync_replicas”的机器没有同时完全关闭
- 超过“min_sync_replicas”的机器完全丢失并且永远不会返回到集群

3、(TODO2): 当设置 `sync_each_write=true` 时，只有当机器的硬盘/SSD 出现故障时，数据才会丢失。 

4、(TODO2): 当设置了 `sync_each_write=true` 且 `min_sync_replicas` 大于零时，只有超过 `min_sync_replicas` 机器完全丢失且不再重新加入集群时，数据才会丢失。